<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Extending Humanity's Healthspan</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,400;9..40,500;9..40,700&family=Inter:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="%PUBLIC_URL%/fonts.css" />
  <!-- HLS.js for video playback -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <!-- 
    Important notes about this implementation:
    1. Videos now use HLS (HTTP Live Streaming) for better compatibility
    2. Video 1 and 3 need loop=true, while 2 and 4 should have loop=false
    3. HLS.js is used for browsers that don't support HLS natively (like Chrome)
  -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: 'Roboto', system-ui, -apple-system, Segoe UI, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .stage { 
      position: fixed; 
      inset: 0; 
      background: #000; 
      width: 100%;
      height: 100%;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .layer { 
      position: absolute; 
      inset: 0; 
      width: 100%;
      height: 100%;
      opacity: 0; 
      transition: opacity 1s linear; 
      pointer-events: none;
      overflow: hidden; /* Prevent content from spilling out */
      will-change: opacity; /* Optimize for layer compositing */
      transform: translateZ(0); /* Force GPU acceleration */
    }
    .layer.active { opacity: 1; }
    video { 
      width: 100%; 
      height: 100%; 
      border: none; 
      background: #000; 
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      object-fit: cover; /* Ensures video covers the entire area */
      display: block; /* Remove any inline-block gaps */
      aspect-ratio: 16 / 9; /* Maintain aspect ratio */
      transform: translate(-50%, -50%); /* Center the video */
      left: 50%;
      top: 50%;
      min-width: 100%; 
      min-height: 100%;
      max-width: none; /* Allow overflow for proper coverage */
      max-height: none; /* Allow overflow for proper coverage */
    }
    .badge {
      position: fixed; top: 16px; left: 16px;
      background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.25);
      padding: 6px 10px; border-radius: 999px; font-weight: 600;
      backdrop-filter: blur(6px); user-select: none; pointer-events: none;
      z-index: 10;
    }
    .controls { position: fixed; top: 16px; right: 16px; display: flex; gap: 8px; z-index: 10; }
    .btn {
      appearance: none; border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.06); color: #fff;
      padding: 6px 10px; border-radius: 8px; cursor: pointer;
    }
    .btn:hover { background: rgba(255,255,255,0.12); }
    .hint {
      position: fixed; bottom: 16px; right: 16px; font-size: 14px; opacity: .75;
      background: rgba(0,0,0,.35); padding: 8px 10px; border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(6px);
      z-index: 10;
    }
    
    /* Media queries for different screen sizes */
    @media (max-width: 768px) {
      iframe {
        width: 100%;
        height: 100%;
        transform: translate(-50%, -50%);
      }
      
      .badge, .controls {
        font-size: 12px;
      }
      
      .hint {
        font-size: 12px;
        max-width: 80%;
      }
    }
    
    @media (orientation: portrait) {
      iframe {
        width: auto;
        height: 100%;
        min-width: 100%;
      }
    }
    
    @media (orientation: landscape) {
      iframe {
        width: 100%;
        height: auto;
        min-height: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <div class="stage" aria-label="Video Stage">
    <div class="layer active" id="layerA">
      <video id="videoA" playsinline webkit-playsinline muted autoplay></video>
    </div>
    <div class="layer" id="layerB">
      <video id="videoB" playsinline webkit-playsinline muted autoplay></video>
    </div>
  </div>

  <div class="badge" id="badge" style="opacity: 0; position: fixed; z-index: -1;">Video: 1</div>

  <!-- Controls removed: Reset to First Video button deleted -->

  <script>
    // === HLS URLs for video streaming ===
    // Using provided HLS playlist URLs for better compatibility
    
    // Detect if device is iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    // HLS video sources
    const SOURCES = {
      // Video 1 - should loop when site loads
      1: "https://vz-3b8e2dcb-339.b-cdn.net/6f66940f-70ad-4431-bcab-486d3047c53d/playlist.m3u8",
      // Video 2 - plays once then goes to video 3
      2: "https://vz-3b8e2dcb-339.b-cdn.net/3b69f9ef-a23a-4551-bd6f-01328b5777bb/playlist.m3u8",
      // Video 3 - should be different from video 2 and should loop
      3: "https://vz-3b8e2dcb-339.b-cdn.net/c68ab894-5fc2-4b8b-907f-ecb3dd15dcc8/playlist.m3u8",
      // Video 4 - plays once then goes to video 1
      4: "https://vz-3b8e2dcb-339.b-cdn.net/8c4625f8-0b01-4e2f-abfb-69a4bc07ec75/playlist.m3u8"
    };
    
    // Configuration for HLS videos
    const HLS_CONFIG = {
      autoStartLoad: true,
      startPosition: -1,
      capLevelToPlayerSize: true,
      debug: false,
      defaultAudioCodec: undefined,
      initialLiveManifestSize: 1,
      maxBufferLength: 30,
      maxMaxBufferLength: 600,
      maxBufferSize: 60 * 1000 * 1000,
      maxBufferHole: 0.5,
      lowLatencyMode: false,
      enableWorker: true
    };

    let activeLayer = 'A';
    let currentVideoId = null; // 1..4
    let inTransition = false;
    let playingOnce = false;
    let preloadedVideos = {}; // Track which videos are preloaded
    let loadedVideos = {}; // Track which videos have been fully loaded once
    let hlsInstances = {}; // Track HLS instances for each video
    let siteInitialLoadComplete = false; // Flag to track if the site has been loaded once

    const layerA = document.getElementById('layerA');
    const layerB = document.getElementById('layerB');
    const videoA = document.getElementById('videoA');
    const videoB = document.getElementById('videoB');
    const badge  = document.getElementById('badge');
  
    function getNextLayerElements() {
      const nextLayer = activeLayer === 'A' ? layerB : layerA;
      const nextVideo = activeLayer === 'A' ? videoB : videoA;
      const curLayer  = activeLayer === 'A' ? layerA : layerB;
      const curVideo  = activeLayer === 'A' ? videoA : videoB;
      return { nextLayer, nextVideo, curLayer, curVideo };
    }

    function setBadge(id) { 
      badge.textContent = `Video: ${id}`;
      console.log(`Badge updated: Video ${id} now active`);
    }

    // Function to get the URL for a specific video
    function getSourceURL(id) {
      return SOURCES[id];
    }
    
    // Enhanced preloading mechanism for HLS videos
    function preloadVideo(id, priority = 'low') {
      if (preloadedVideos[id] || !SOURCES[id]) return;
      
      console.log(`Preloading video ${id} with ${priority} priority...`);
      
      // Create preload link for resource hint
      const preloadLink = document.createElement('link');
      preloadLink.rel = 'preload';
      preloadLink.href = SOURCES[id];
      preloadLink.as = 'fetch';
      preloadLink.type = 'application/vnd.apple.mpegurl';
      preloadLink.importance = priority; // 'high', 'low', or 'auto'
      document.head.appendChild(preloadLink);
      
      // Create a hidden video element for preloading
      const hiddenPreloader = document.createElement('video');
      hiddenPreloader.style.position = 'absolute';
      hiddenPreloader.style.width = '1px';
      hiddenPreloader.style.height = '1px';
      hiddenPreloader.style.opacity = '0';
      hiddenPreloader.style.pointerEvents = 'none';
      hiddenPreloader.setAttribute('aria-hidden', 'true');
      hiddenPreloader.style.display = 'none';
      hiddenPreloader.muted = true;
      hiddenPreloader.autoplay = false;
      hiddenPreloader.playsInline = true;
      hiddenPreloader.setAttribute('webkit-playsinline', '');
      hiddenPreloader.preload = 'auto';
      hiddenPreloader.dataset.preloadId = id;
      document.body.appendChild(hiddenPreloader);
      
      // Initialize HLS
      if (Hls.isSupported()) {
        const hls = new Hls(HLS_CONFIG);
        hls.loadSource(SOURCES[id]);
        hls.attachMedia(hiddenPreloader);
        hls.on(Hls.Events.MANIFEST_PARSED, function() {
          console.log(`Video ${id} HLS manifest loaded successfully`);
        });
        
        hls.on(Hls.Events.ERROR, function(event, data) {
          if (data.fatal) {
            console.error(`Fatal error with video ${id} preloading:`, data.type);
            hls.destroy();
          }
        });
        
        // Store the HLS instance for future reference
        if (!hlsInstances[`preload-${id}`]) {
          hlsInstances[`preload-${id}`] = hls;
        }
      } else if (hiddenPreloader.canPlayType('application/vnd.apple.mpegurl')) {
        // Native HLS support (iOS Safari)
        hiddenPreloader.src = SOURCES[id];
        hiddenPreloader.load();
        console.log(`Video ${id} using native HLS support for preloading`);
      }
      
      // Set a timeout to clean up the preloader element
      setTimeout(() => {
        if (document.contains(hiddenPreloader)) {
          // Destroy HLS instance if it exists
          if (hlsInstances[`preload-${id}`]) {
            hlsInstances[`preload-${id}`].destroy();
            delete hlsInstances[`preload-${id}`];
          }
          hiddenPreloader.remove();
        }
      }, 180000); // 3 minutes retention
      
      preloadedVideos[id] = true;
    }

    async function crossfadeTo(id, { loop = false } = {}) {
      if (!SOURCES[id]) return;
      if (inTransition) return;
      inTransition = true;

      const { nextLayer, nextVideo, curLayer, curVideo } = getNextLayerElements();
      console.log('Switching to video:', id, loop ? '(looping)' : '(once)');
      
      // Dispatch custom events for ScrambledText component
      // If we're transitioning FROM video 1, fade out the text
      if (currentVideoId === 1 && id !== 1) {
        console.log('Fading OUT scrambled text (leaving video 1)');
        window.dispatchEvent(new CustomEvent('video1-fade-out'));
      }
      
      // If we're transitioning TO video 1, fade in the text
      if (id === 1) {
        console.log('Fading IN scrambled text (entering video 1)');
        // Slight delay to match the crossfade timing
        setTimeout(() => {
          window.dispatchEvent(new CustomEvent('video1-fade-in'));
        }, 500);
      }
      
      // If we're transitioning FROM video 3, fade out the text
      if (currentVideoId === 3 && id !== 3) {
        console.log('Fading OUT TextType (leaving video 3)');
        window.dispatchEvent(new CustomEvent('video3-fade-out'));
      }
      
      // If we're transitioning TO video 3, fade in the text
      if (id === 3) {
        console.log('Fading IN TextType (entering video 3)');
        // Slight delay to match the crossfade timing
        setTimeout(() => {
          window.dispatchEvent(new CustomEvent('video3-fade-in'));
        }, 500);
      }
      
      // Set up video with HLS
      // If we have a previous HLS instance for this video, destroy it
      if (hlsInstances[activeLayer === 'A' ? 'B' : 'A']) {
        hlsInstances[activeLayer === 'A' ? 'B' : 'A'].destroy();
        delete hlsInstances[activeLayer === 'A' ? 'B' : 'A'];
      }
      
      // Set video loop property based on video ID (1 and 3 should loop)
      nextVideo.loop = (id === 1 || id === 3);
      
      // Initialize HLS.js for the video if supported
      if (Hls.isSupported()) {
        const hls = new Hls(HLS_CONFIG);
        hls.loadSource(getSourceURL(id));
        hls.attachMedia(nextVideo);
        
        // Store the HLS instance
        hlsInstances[activeLayer === 'A' ? 'B' : 'A'] = hls;
        
        hls.on(Hls.Events.MANIFEST_PARSED, function() {
          console.log(`Video ${id} manifest parsed, starting playback`);
          nextVideo.play().catch(e => {
            console.error('Error playing video:', e);
            
            // Try again with user interaction if autoplay fails
            document.addEventListener('click', function playOnClick() {
              nextVideo.play();
              document.removeEventListener('click', playOnClick);
            }, { once: true });
          });
          
          // Show the next video with crossfade
          nextLayer.classList.add('active');
          curLayer.classList.remove('active');
          
          // Update tracking variables
          activeLayer = (activeLayer === 'A') ? 'B' : 'A';
          currentVideoId = id;
          setBadge(id);
          
          // Mark as loaded
          loadedVideos[id] = true;
          
          // Clean up current video after transition
          setTimeout(() => {
            if (curVideo.pause) {
              curVideo.pause();
              curVideo.removeAttribute('src');
              curVideo.load();
            }
            inTransition = false;
            
            // Mark site as loaded after first video completes transition
            if (!siteInitialLoadComplete) {
              siteInitialLoadComplete = true;
              console.log("Initial site load complete");
            }
            
            console.log(`Video ${id} now active and visible`);
            
            // Advanced preloading strategy
            if (id === 1) {
              preloadVideo(2, 'high'); // Next direct in sequence - high priority
              setTimeout(() => {
                preloadVideo(3, 'high'); // Will be needed after video 2
                setTimeout(() => {
                  preloadVideo(4, 'low'); // Will be needed after video 3
                }, 1000);
              }, 1000);
            } else if (id === 2) {
              preloadVideo(3, 'high'); // Next direct in sequence - high priority
              preloadVideo(4, 'low');  // Will be needed after video 3
            } else if (id === 3) {
              preloadVideo(4, 'high'); // Next direct in sequence - high priority
              preloadVideo(1, 'low');  // Will be needed after video 4
            } else if (id === 4) {
              preloadVideo(1, 'high'); // Next direct in sequence - high priority
              preloadVideo(2, 'low');  // Will be needed after video 1
            }
          }, 1000);
          
          // Show hint text only when video 1 is playing, hide for all others
          const hintText = document.getElementById('hintText');
          if (hintText) {
            if (id === 1) {
              hintText.style.display = 'block';
            } else {
              hintText.style.display = 'none';
            }
          }
        });
        
        // Add error handling
        hls.on(Hls.Events.ERROR, function(event, data) {
          console.error(`HLS error for video ${id}:`, data);
          if (data.fatal) {
            console.error(`Fatal error with video ${id}:`, data.type);
            
            // Try to recover
            switch(data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                console.log('Network error, trying to recover...');
                hls.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                console.log('Media error, trying to recover...');
                hls.recoverMediaError();
                break;
              default:
                console.error('Unrecoverable error, destroying HLS instance');
                hls.destroy();
                
                // Fall back to native player if possible
                if (nextVideo.canPlayType('application/vnd.apple.mpegurl')) {
                  nextVideo.src = getSourceURL(id);
                  nextVideo.play().catch(e => console.error('Native fallback error:', e));
                }
                break;
            }
          }
        });
      } else if (nextVideo.canPlayType('application/vnd.apple.mpegurl')) {
        // For browsers with native HLS support (iOS Safari)
        console.log(`Using native HLS support for video ${id}`);
        nextVideo.src = getSourceURL(id);
        
        // Play the video
        nextVideo.play().catch(e => {
          console.error('Error playing video with native HLS:', e);
        });
        
        // Set up loadedmetadata event to handle transition
        nextVideo.onloadedmetadata = function() {
          // Show the next video with crossfade
          nextLayer.classList.add('active');
          curLayer.classList.remove('active');
          
          // Update tracking variables
          activeLayer = (activeLayer === 'A') ? 'B' : 'A';
          currentVideoId = id;
          setBadge(id);
          loadedVideos[id] = true;
          
          // Clean up current video
          setTimeout(() => {
            if (curVideo.pause) {
              curVideo.pause();
              curVideo.removeAttribute('src');
              curVideo.load();
            }
            inTransition = false;
            
            if (!siteInitialLoadComplete) {
              siteInitialLoadComplete = true;
            }
            
            // Preload next videos
            if (id === 1) preloadVideo(2, 'high');
            else if (id === 2) preloadVideo(3, 'high');
            else if (id === 3) preloadVideo(4, 'high');
            else if (id === 4) preloadVideo(1, 'high');
          }, 1000);
        };
        
        // Error handler for native playback
        nextVideo.onerror = function(e) {
          console.error(`Error with native HLS playback for video ${id}:`, e);
        };
      } else {
        console.error('HLS is not supported in this browser, attempting graceful degradation');
        
        // Show a static background instead of video
        nextLayer.style.background = '#000';
        nextLayer.innerHTML = `
          <div style="
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            color: #fff;
            font-family: 'Roboto', sans-serif;
            text-align: center;
            opacity: 0.3;
          ">
            <div>Video ${id}</div>
          </div>
        `;
        
        // Still proceed with the layer transition
        nextLayer.classList.add('active');
        curLayer.classList.remove('active');
        
        activeLayer = (activeLayer === 'A') ? 'B' : 'A';
        currentVideoId = id;
        setBadge(id);
        
        setTimeout(() => {
          inTransition = false;
        }, 1000);
      }
    }

    // Store actual video durations
    let videoDurations = {
      1: 49000, // Fallback values
      2: 6300,
      3: 32000,
      4: 5000
    };

    // Function to get actual video duration
    function getVideoDuration(videoElement) {
      if (videoElement && !isNaN(videoElement.duration) && videoElement.duration > 0) {
        return videoElement.duration * 1000; // Convert to milliseconds
      }
      return null;
    }

    async function playOnceThen(nextId, thenId, thenLoop=true) {
      playingOnce = true;
      await crossfadeTo(nextId, { loop: false });
      
      // Use fallback durations for now since actual duration detection is unreliable
      // during rapid transitions. We'll detect duration after the video is fully loaded.
      let duration = videoDurations[nextId] || 15000;
      console.log(`Using duration for video ${nextId}: ${duration}ms`);
      
      // Set up a timeout to detect actual duration after the video loads
      setTimeout(() => {
        const currentVideo = activeLayer === 'A' ? videoA : videoB;
        const actualDuration = getVideoDuration(currentVideo);
        if (actualDuration && Math.abs(actualDuration - videoDurations[nextId]) > 1000) {
          // Only update if the difference is significant (>1 second)
          videoDurations[nextId] = actualDuration;
          console.log(`Updated duration cache for video ${nextId}: ${actualDuration}ms`);
        }
      }, 2000); // Check after 2 seconds when video should be loaded
      
      setTimeout(async () => {
        console.log(`Video ${nextId} duration completed, switching to ${thenId}`);
        playingOnce = false;
        await crossfadeTo(thenId, { loop: thenLoop });
      }, duration);
    }

    // Track scroll progress to predict upcoming video needs
    let scrollProgress = 0;
    const scrollThresholds = {
      firstTransition: 30,   // % progress when we should preload video 2
      secondTransition: 60,  // % progress when we should preload video 3 and 4
      thirdTransition: 85    // % progress when we should prepare for wrap-around
    };
    
    function updateScrollProgress(dir, amount = 5) {
      if (dir === 'down') {
        scrollProgress = Math.min(100, scrollProgress + amount);
      } else if (dir === 'up') {
        scrollProgress = Math.max(0, scrollProgress - amount);
      }
      
      // Predictive preloading based on scroll position
      if (scrollProgress >= scrollThresholds.firstTransition && 
          scrollProgress < scrollThresholds.secondTransition) {
        if (currentVideoId === 1) {
          preloadVideo(2, 'high');
        }
      } else if (scrollProgress >= scrollThresholds.secondTransition && 
                scrollProgress < scrollThresholds.thirdTransition) {
        if (currentVideoId === 1 || currentVideoId === 2) {
          preloadVideo(3, 'high');
        }
      } else if (scrollProgress >= scrollThresholds.thirdTransition) {
        if (currentVideoId === 3) {
          preloadVideo(4, 'high');
        }
        preloadVideo(1, 'low'); // Prepare for wrap around
      }
    }

    function handleScrollDirection(dir) {
      if (inTransition || playingOnce) return;
      
      // Update scroll progress before handling the direction
      updateScrollProgress(dir);
      
      if (dir === 'down') {
        // Scroll down: only go from video 1 to video 3
        switch(currentVideoId) {
          case 1:
            // From main video 1, go to transition video 2, then to main video 3
            // Before making the transition, ensure video 3 is preloaded since it's next after 2
            preloadVideo(3, 'high');
            playOnceThen(2, 3, true);
            break;
          case 3:
            // If we're already on video 3 and scrolling down, do nothing
            // This prevents looping back to video 1 when scrolling down from video 3
            console.log('Already at the bottom video (3), ignoring scroll down');
            break;
          default:
            // If we're somehow on a transition video directly, go to video 1
            crossfadeTo(1, { loop: true });
        }
      } else if (dir === 'up') {
        // Scroll up: only go from video 3 to video 1
        if (currentVideoId === 3) {
          // Only respond to scroll up if we're on video 3
          preloadVideo(1, 'high'); // Preload video 1 since we'll need it after video 4
          playOnceThen(4, 1, true); // Play transition video 4 once, then switch to video 1 (looping)
        } else if (currentVideoId === 1) {
          // If we're already on video 1 and scrolling up, do nothing
          // This prevents restarting video 1 when scrolling up
          console.log('Already at the top video (1), ignoring scroll up');
        }
      }
    }

    let wheelTimeout = null;
    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      const dir = e.deltaY > 0 ? 'down' : (e.deltaY < 0 ? 'up' : null);
      if (!dir) return;
      clearTimeout(wheelTimeout);
      wheelTimeout = setTimeout(() => handleScrollDirection(dir), 40);
    }, { passive: false });

    let touchStartY = null;
    window.addEventListener('touchstart', (e) => { touchStartY = e.touches[0].clientY; }, { passive: true });
    window.addEventListener('touchmove', (e) => {
      if (touchStartY == null) return;
      const dy = e.touches[0].clientY - touchStartY;
      if (Math.abs(dy) < 30) return;
      const dir = dy < 0 ? 'down' : 'up';
      touchStartY = e.touches[0].clientY;
      handleScrollDirection(dir);
    }, { passive: true });
    
  // Removed restart button event listener

    // Add support for Intersection Observer to detect when video elements are nearing the viewport
    function setupIntersectionObserver() {
      // Create sentinel elements that will trigger video preloading
      // These are positioned at strategic scroll positions
      const sentinels = [
        { id: 'sentinel-video2', videoId: 2, position: '25%' },
        { id: 'sentinel-video3', videoId: 3, position: '50%' },
        { id: 'sentinel-video4', videoId: 4, position: '75%' }
      ];
      
      // Create and position sentinel elements
      sentinels.forEach(sentinel => {
        const element = document.createElement('div');
        element.id = sentinel.id;
        element.style.position = 'absolute';
        element.style.top = sentinel.position;
        element.style.left = '0';
        element.style.width = '1px';
        element.style.height = '1px';
        element.style.opacity = '0';
        element.style.pointerEvents = 'none';
        element.setAttribute('aria-hidden', 'true');
        element.dataset.videoId = sentinel.videoId;
        document.body.appendChild(element);
      });
      
      // Set up Intersection Observer
      const observerOptions = {
        rootMargin: '50% 0px', // Start loading when element is 50% of the viewport height away
        threshold: 0.1
      };
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const videoId = parseInt(entry.target.dataset.videoId);
            if (videoId && !preloadedVideos[videoId]) {
              console.log(`Sentinel for video ${videoId} entered viewport margin, preloading...`);
              preloadVideo(videoId, 'high');
              
              // If this is video 2 or 4 (transition videos), also preload the next main video
              if (videoId === 2) {
                setTimeout(() => preloadVideo(3, 'high'), 500);
              } else if (videoId === 4) {
                setTimeout(() => preloadVideo(1, 'high'), 500);
              }
              
              // Stop observing once we've triggered the preload
              observer.unobserve(entry.target);
            }
          }
        });
      }, observerOptions);
      
      // Start observing the sentinel elements
      sentinels.forEach(sentinel => {
        const element = document.getElementById(sentinel.id);
        if (element) {
          observer.observe(element);
        }
      });
    }
    
    // Function to check if video is loading properly
    function checkVideoLoading() {
      console.log("Checking if videos are loading properly...");
      
      // For iOS devices which are more problematic
      if (isIOS) {
        let videoLoadTimeout;
        let videoLoadAttempts = 0;
        const maxAttempts = 3;
        
        const checkVideoStatus = () => {
          videoLoadAttempts++;
          console.log(`iOS video load check attempt: ${videoLoadAttempts}/${maxAttempts}`);
          
          const videoA = document.getElementById('videoA');
          const videoB = document.getElementById('videoB');
          
          // Check if iframe content is accessible
          let videoALoaded = false;
          let videoBLoaded = false;
          
          try {
            // Try to access iframe content which will throw errors if blocked
            if (videoA && videoA.contentWindow) {
              videoALoaded = true;
            }
            if (videoB && videoB.contentWindow) {
              videoBLoaded = true;
            }
          } catch (e) {
            console.error("Error accessing iframe content:", e);
          }
          
          console.log(`Video loading status - A: ${videoALoaded ? 'OK' : 'FAIL'}, B: ${videoBLoaded ? 'OK' : 'FAIL'}`);
          
          // If videos aren't loading after multiple attempts, switch to fallback
          if ((!videoALoaded || !videoBLoaded) && videoLoadAttempts >= maxAttempts) {
            console.warn("Videos failed to load properly after multiple attempts, using fallback");
            setupFallbackImages();
          } else if (videoLoadAttempts < maxAttempts) {
            // Try again in a few seconds
            videoLoadTimeout = setTimeout(checkVideoStatus, 2000);
          }
        };
        
        // Start checking video loading status
        videoLoadTimeout = setTimeout(checkVideoStatus, 3000);
      }
    }
    
    // Setup fallback images if videos fail to load
    function setupFallbackImages() {
      console.log("Setting up fallback static images instead of videos");
      
      // Create fallback image elements
      const createFallbackImage = (videoId) => {
        // Map video IDs to appropriate fallback images
        // You'll need to provide actual image URLs here
        const fallbackImageUrls = {
          1: 'https://placehold.co/1920x1080/000000/FFFFFF/png?text=Video+1+Fallback',
          2: 'https://placehold.co/1920x1080/000000/FFFFFF/png?text=Video+2+Fallback',
          3: 'https://placehold.co/1920x1080/000000/FFFFFF/png?text=Video+3+Fallback', 
          4: 'https://placehold.co/1920x1080/000000/FFFFFF/png?text=Video+4+Fallback'
        };
        
        const img = document.createElement('img');
        img.src = fallbackImageUrls[videoId] || fallbackImageUrls[1];
        img.style.position = 'absolute';
        img.style.inset = '0';
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.alt = `Fallback image for video ${videoId}`;
        
        return img;
      };
      
      // Replace videos with fallback images
      const videoA = document.getElementById('videoA');
      const videoB = document.getElementById('videoB');
      const layerA = document.getElementById('layerA');
      const layerB = document.getElementById('layerB');
      
      // Clean up any HLS instances first
      Object.keys(hlsInstances).forEach(key => {
        hlsInstances[key].destroy();
      });
      hlsInstances = {};
      
      if (videoA && layerA) {
        const fallbackA = createFallbackImage(currentVideoId || 1);
        videoA.style.display = 'none';
        layerA.insertBefore(fallbackA, videoA);
      }
      
      if (videoB && layerB) {
        const fallbackB = createFallbackImage(2);  // Default to video 2 for layerB
        videoB.style.display = 'none';
        layerB.insertBefore(fallbackB, videoB);
      }
      
      // Modify crossfade behavior for static images
      window.originalCrossfadeTo = window.crossfadeTo;
      window.crossfadeTo = function(id, options = {}) {
        console.log(`Static image fallback: switching to image ${id}`);
        
        // Update current video ID and badge
        currentVideoId = id;
        if (badge) badge.textContent = `Image: ${id}`;
        
        // Get layers
        const nextLayer = activeLayer === 'A' ? layerB : layerA;
        const curLayer = activeLayer === 'A' ? layerA : layerB;
        
        // Replace the fallback image in the next layer
        const nextVideo = activeLayer === 'A' ? videoB : videoA;
        const existingImg = nextLayer.querySelector('img');
        if (existingImg) nextLayer.removeChild(existingImg);
        
        const newFallback = createFallbackImage(id);
        nextLayer.insertBefore(newFallback, nextVideo);
        
        // Crossfade to the next layer
        nextLayer.classList.add('active');
        curLayer.classList.remove('active');
        
        // Toggle active layer
        activeLayer = activeLayer === 'A' ? 'B' : 'A';
        
        // Dispatch appropriate events based on the image ID
        if (id === 1) {
          setTimeout(() => {
            window.dispatchEvent(new CustomEvent('video1-fade-in'));
          }, 500);
        } else if (id === 3) {
          setTimeout(() => {
            window.dispatchEvent(new CustomEvent('video3-fade-in'));
          }, 500);
        }
      };
      
      // Trigger initial fade-in
      window.dispatchEvent(new CustomEvent('video1-fade-in'));
    }
    
    // Initialize videos on page load
    window.addEventListener('DOMContentLoaded', () => {
      console.log("Page loaded, initializing first video");
      
      // Trigger event to make scrambled text visible with video 1
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('video1-fade-in'));
        console.log("Dispatched video1-fade-in event on page load");
      }, 500);
      
      // Setup advanced preloading with intersection observers
      setupIntersectionObserver();
      
      // Start preloading videos
      preloadVideo(2, 'high');
      
      // Start with video 1
      setTimeout(() => {
        crossfadeTo(1, { loop: true });
        
        // Aggressive preloading strategy - load all videos quickly
        setTimeout(() => {
          // Preload remaining videos
          preloadVideo(3, 'high');
          preloadVideo(4, 'high');
          
          console.log("All videos are being aggressively preloaded");
        }, 1000);
      }, 300);
    });
  </script>
  
  <!-- Include the video helper script at the end for best performance -->
  <script src="%PUBLIC_URL%/video-helper.js"></script>
</body>
</html>
